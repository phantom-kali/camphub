# Copilot Instructions for Django DRF API Documentation

## Context

You are working on a Django REST Framework project that needs complete API documentation for frontend integration. The frontend developer requires comprehensive Swagger/OpenAPI documentation to integrate successfully.

## Mandatory Rules for All API Code Generation

### Rule 1: Every API View Must Include Complete Documentation

When generating or modifying any APIView, ViewSet, or generic view:

- ALWAYS add `@swagger_auto_schema` decorator to APIView methods
- ALWAYS specify `serializer_class` attribute for ViewSets and Generic views
- NEVER generate an endpoint without proper documentation

```python
# Required imports for documentation
from drf_yasg.utils import swagger_auto_schema
from drf_yasg import openapi

# Example pattern you must follow:
@swagger_auto_schema(
    operation_description="Detailed description of what this endpoint does",
    request_body=YourSerializer,
    responses={
        200: openapi.Response('Success description', YourSerializer),
        400: openapi.Response('Validation error'),
        401: openapi.Response('Authentication required'),
    },
    tags=['endpoint-category']
)
def post(self, request):
    # view logic
```

### Rule 2: All Serializer Fields Must Have Documentation

When creating or modifying serializers:

- ALWAYS add `help_text` to every field
- ALWAYS specify `required` parameter explicitly
- ALWAYS add custom `error_messages` for validation
- ALWAYS use the most specific field type available

```python
# Pattern you must follow for all serializer fields:
field_name = serializers.CharField(
    max_length=100,
    required=True,
    help_text="Clear, specific description of this field's purpose and requirements",
    error_messages={
        'required': 'This field is required',
        'max_length': 'Maximum 100 characters allowed'
    }
)
```

### Rule 3: Document All HTTP Methods and Response Codes

For every endpoint you generate:

- ALWAYS document responses for: 200/201, 400, 401, 403, 404
- ALWAYS include example response data
- ALWAYS specify the correct HTTP method in operation description

```python
responses={
    200: openapi.Response(
        'Success',
        YourSerializer,
        examples={
            'application/json': {
                'id': 1,
                'field': 'example_value',
                'created_at': '2024-01-01T00:00:00Z'
            }
        }
    ),
    400: openapi.Response(
        'Validation Error',
        examples={
            'application/json': {
                'field_name': ['Error message'],
                'non_field_errors': ['General error message']
            }
        }
    )
}
```

### Rule 4: Always Document Request Bodies with Examples

When generating endpoints that accept data:

- ALWAYS show required vs optional fields
- ALWAYS provide example request data
- ALWAYS document field constraints and validation rules

```python
# For complex request bodies, use this pattern:
request_body=openapi.Schema(
    type=openapi.TYPE_OBJECT,
    required=['required_field1', 'required_field2'],
    properties={
        'required_field1': openapi.Schema(
            type=openapi.TYPE_STRING,
            description='Specific description with constraints',
            example='realistic_example_value'
        ),
        'optional_field': openapi.Schema(
            type=openapi.TYPE_STRING,
            description='Description for optional field',
            example='optional_example'
        ),
    }
)
```

### Rule 5: Document All Query Parameters

When generating list views or filtered endpoints:

- ALWAYS document pagination parameters
- ALWAYS document search/filter parameters
- ALWAYS specify parameter types and requirements

```python
manual_parameters=[
    openapi.Parameter(
        'search',
        openapi.IN_QUERY,
        description="Search term for filtering results by name or description",
        type=openapi.TYPE_STRING,
        required=False
    ),
    openapi.Parameter(
        'page',
        openapi.IN_QUERY,
        description="Page number for pagination (default: 1)",
        type=openapi.TYPE_INTEGER,
        required=False
    ),
    openapi.Parameter(
        'ordering',
        openapi.IN_QUERY,
        description="Sort results by field (use '-' prefix for descending)",
        type=openapi.TYPE_STRING,
        required=False
    ),
]
```

### Rule 6: Authentication Documentation Requirements

For any endpoint that requires authentication:

- ALWAYS add `security=[{'Bearer': []}]` to swagger_auto_schema
- ALWAYS document authentication in operation description
- ALWAYS include 401 response in responses dict

### Rule 7: File Upload Endpoint Documentation

When generating file upload endpoints:

- ALWAYS use `consumes=['multipart/form-data']`
- ALWAYS document accepted file types and size limits
- ALWAYS use `openapi.TYPE_STRING, format='binary'` for file fields

```python
@swagger_auto_schema(
    operation_description="Upload file with size limit and type restrictions",
    request_body=openapi.Schema(
        type=openapi.TYPE_OBJECT,
        properties={
            'file': openapi.Schema(
                type=openapi.TYPE_STRING,
                format='binary',
                description='File upload (PDF, JPG, PNG only, max 10MB)'
            ),
            'description': openapi.Schema(
                type=openapi.TYPE_STRING,
                description='Optional file description'
            )
        }
    ),
    consumes=['multipart/form-data']
)
```

### Rule 8: Consistent Error Response Format

ALWAYS generate error responses in this format:

```python
400: openapi.Response(
    'Validation Error',
    examples={
        'application/json': {
            'success': False,
            'errors': {
                'field_name': ['Specific error message for this field'],
                'non_field_errors': ['General validation errors']
            },
            'message': 'Brief error summary'
        }
    }
)
```

### Rule 9: Success Response Format

ALWAYS generate success responses in this format:

```python
200: openapi.Response(
    'Success',
    YourSerializer,
    examples={
        'application/json': {
            'success': True,
            'data': {
                # actual data structure here
            },
            'message': 'Operation completed successfully'
        }
    }
)
```

### Rule 10: Validation and Custom Methods Documentation

When generating custom validation or methods:

- ALWAYS document validation rules in serializer help_text
- ALWAYS provide clear error messages for validation failures
- ALWAYS document custom serializer methods

```python
def validate_field_name(self, value):
    """Document what this validation checks"""
    if not condition:
        raise serializers.ValidationError("Clear, actionable error message")
    return value
```

## Endpoint-Specific Requirements

### Authentication Endpoints

When generating login/register/password reset endpoints:

- ALWAYS document token response format
- ALWAYS include examples of successful authentication
- ALWAYS document all required fields with validation rules

### CRUD Endpoints

- **Create**: Document all required fields, validation rules, and created resource response
- **Read**: Document query parameters, pagination, and response structure
- **Update**: Specify partial vs full update, document updatable fields
- **Delete**: Document success response (204) and cascade behavior

### List Endpoints

- ALWAYS include pagination documentation
- ALWAYS document filtering and search options
- ALWAYS document ordering parameters

## Code Quality Requirements

### Naming Conventions

- Use descriptive operation descriptions
- Use consistent tag names for grouping
- Use realistic example data that matches your domain

### Integration Support

- ALWAYS provide cURL examples in operation descriptions when helpful
- ALWAYS document base URL requirements
- ALWAYS specify content-type requirements

## Testing Requirements

Before generating final code:

- Ensure all endpoints appear correctly in Swagger UI
- Verify all parameters are visible and documented
- Check that examples are realistic and helpful
- Confirm error responses are properly documented

## Error Prevention

NEVER generate:

- Endpoints without @swagger_auto_schema or serializer_class
- Serializer fields without help_text
- Views without proper response documentation
- Authentication endpoints without security documentation
- File uploads without consumes specification

## Integration Success Criteria

Every endpoint you generate must enable a frontend developer to:

1. Understand what data to send without reading backend code
2. Know exactly what response to expect
3. Handle all possible error scenarios
4. Test the endpoint directly from Swagger UI
5. Implement the integration using only the API documentation

Remember: The frontend developer should never need to ask questions about your API structure, required fields, or response formats if the documentation follows these rules.
